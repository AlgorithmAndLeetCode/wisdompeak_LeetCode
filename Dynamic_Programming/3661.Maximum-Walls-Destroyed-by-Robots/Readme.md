### 3661.Maximum-Walls-Destroyed-by-Robots

直观上容易想到这是DP，因为每个robot只有两种决策，所以容易设计dp[i][j]表示从前往后处理，当第i个机器人选择j方向(0或者1）时能得到的最优解。转移方程也不难写出：
```
dp[i][0] = max(dp[i-1][1]+shoot(i,0)-overlap(i), dp[i-1][0]+shoot(i,0));            
dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + shoot(i,1);
```
其中shoot(i,0)表示第i号机器人朝左射击时能够击中的墙壁个数，shoot(i,1)表示第i号机器人朝右射击时能够击中的墙壁个数。overlap(i)表示当i-1号与i号机器人对射时，总共所能击中的墙壁个数。

稍微解释一下：对于dp[i][0]，它的前驱状态有两种dp[i-1][0]和dp[i-1][1]。对于前者，因为相邻两个机器人对射，所以我们要减去两者击中墙壁里重合的个数。

计算shoot(i,0)时，我们需要统计在```[robot[i]-distance[i], robot[i]]```区间内有多少个墙。根据规则，子弹不能击穿相邻的机器人，所以对于区间的左端点，需要与robot[i-1]之间取大。事实上此处有一个细节：加入robot[i-1]恰好有一座墙，那么它的击穿是属于第i-1号机器人还是第i号机器人？为了避免重复计数，我们约定，任何恰好在robot[i]处的墙，我们认为只是被第i号机器人击穿的。所以区间左端点应该是`max(robot[i]-distance[i], robot[i-1]+1)`。

同理，计算shoot(i,1)时，我们需要统计```[robot[i], right]```区间内有多少墙，其中`right = min(robot[i]+distance[i], robot[i+1]-1)`.

对于overlap(i)，它的表达式就是`shoot(i-1,1) + shoot(i, 0)`减去两个机器人之间的墙的个数。如果减出来的值是负数，那么返回0（因为不可能有负数个的重合）。

